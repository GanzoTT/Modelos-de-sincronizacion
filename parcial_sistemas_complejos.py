# -*- coding: utf-8 -*-
"""Parcial Sistemas Complejos

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1C8Bv0MLk0r23WC29pvVpXVkb-7fCrfQv
"""

# ===========================================
# Simulación y comparación de sincronización:
#  Modelos de Kuramoto y Winfree
# ===========================================

import numpy as np
import matplotlib.pyplot as plt

# ----------------------------
# CONFIGURACIÓN GENERAL
# ----------------------------
N = 120              # número de osciladores (moderado para velocidad)
T = 40.0             # tiempo total de simulación
dt = 0.02            # paso temporal
steps = int(T/dt)
t = np.linspace(0, T, steps)

np.random.seed(42)   # reproducibilidad

omega_mean = 2.0
omega_std = 0.3
omega = np.random.normal(omega_mean, omega_std, N)
theta0 = np.random.uniform(0, 2*np.pi, N)

# ----------------------------
# FUNCIONES AUXILIARES
# ----------------------------
def order_parameter(theta):
    """Devuelve el parámetro de orden r y su fase media psi"""
    complex_order = np.mean(np.exp(1j * theta))
    return np.abs(complex_order), np.angle(complex_order)

# Funciones P y Q para el modelo de Winfree
def P_func(theta): return 1 + np.cos(theta)
def Q_func(theta): return -np.sin(theta)

# ----------------------------
# MÉTODO RK4 GENERAL
# ----------------------------
def rk4_step(func, theta, dt):
    k1 = func(theta)
    k2 = func(theta + 0.5*dt*k1)
    k3 = func(theta + 0.5*dt*k2)
    k4 = func(theta + dt*k3)
    return theta + (dt/6)*(k1 + 2*k2 + 2*k3 + k4)

# ----------------------------
# MODELO DE KURAMOTO
# ----------------------------
def kuramoto_rhs(theta, omega, K):
    N = len(theta)
    diff = theta[None, :] - theta[:, None]
    coupling = (K/N) * np.sum(np.sin(diff), axis=1)
    return omega + coupling

def simulate_kuramoto(theta0, omega, K, dt, steps):
    theta = theta0.copy()
    thetas = np.zeros((steps, len(theta)))
    r_t = np.zeros(steps)
    for i in range(steps):
        r_t[i], _ = order_parameter(theta)
        thetas[i] = theta
        theta = rk4_step(lambda th: kuramoto_rhs(th, omega, K), theta, dt)
        theta = np.mod(theta, 2*np.pi)
    return thetas, r_t

# ----------------------------
# MODELO DE WINFREE
# ----------------------------
def winfree_rhs(theta, omega, K):
    N = len(theta)
    P_vals = P_func(theta)
    Q_vals = Q_func(theta)
    global_drive = (K/N) * np.sum(P_vals)
    return omega + Q_vals * global_drive

def simulate_winfree(theta0, omega, K, dt, steps):
    theta = theta0.copy()
    thetas = np.zeros((steps, len(theta)))
    r_t = np.zeros(steps)
    for i in range(steps):
        r_t[i], _ = order_parameter(theta)
        thetas[i] = theta
        theta = rk4_step(lambda th: winfree_rhs(th, omega, K), theta, dt)
        theta = np.mod(theta, 2*np.pi)
    return thetas, r_t

# ----------------------------
# SIMULACIÓN PRINCIPAL
# ----------------------------
K_kur = 1.6
K_win = 2.2
print("Simulando Kuramoto y Winfree...")
thetas_kur, r_kur = simulate_kuramoto(theta0, omega, K_kur, dt, steps)
thetas_win, r_win = simulate_winfree(theta0, omega, K_win, dt, steps)

# ----------------------------
# VISUALIZACIONES PRINCIPALES
# ----------------------------

# r(t) comparativo
plt.figure(figsize=(9,4))
plt.plot(t, r_kur, label='Kuramoto')
plt.plot(t, r_win, label='Winfree', linestyle='--')
plt.xlabel("Tiempo")
plt.ylabel("r(t)")
plt.title("Comparación del parámetro de orden r(t)")
plt.legend()
plt.grid(True)
plt.show()

# Raster (muestra de osciladores)
sample_idx = np.random.choice(range(N), size=25, replace=False)
plt.figure(figsize=(10,5))
for i in sample_idx:
    plt.plot(t, thetas_kur[:, i], lw=0.7)
plt.xlabel("Tiempo"); plt.ylabel("Fase (rad)")
plt.title("Raster (muestra) — Kuramoto")
plt.ylim(0, 2*np.pi); plt.show()

plt.figure(figsize=(10,5))
for i in sample_idx:
    plt.plot(t, thetas_win[:, i], lw=0.7)
plt.xlabel("Tiempo"); plt.ylabel("Fase (rad)")
plt.title("Raster (muestra) — Winfree")
plt.ylim(0, 2*np.pi); plt.show()

# Diagramas polares finales
def plot_polar_final(theta_final, titulo):
    plt.figure(figsize=(5,5))
    ax = plt.subplot(111, polar=True)
    ax.scatter(theta_final, np.ones_like(theta_final), s=20)
    ax.set_title(titulo)
    plt.show()

plot_polar_final(thetas_kur[-1], "Fases finales — Kuramoto")
plot_polar_final(thetas_win[-1], "Fases finales — Winfree")

# ----------------------------
# Barrido de K: transición de sincronización
# ----------------------------
def sweep_K(model_func, theta0, omega, K_values):
    r_final = []
    for K in K_values:
        thetas, r_t = model_func(theta0, omega, K, dt, steps)
        r_final.append(r_t[-1])
    return np.array(r_final)

K_values = np.linspace(0, 4, 25)
print("Realizando barrido de K (Kuramoto)...")
rK = sweep_K(simulate_kuramoto, theta0, omega, K_values)
print("Realizando barrido de K (Winfree)...")
rW = sweep_K(simulate_winfree, theta0, omega, K_values)

plt.figure(figsize=(8,4))
plt.plot(K_values, rK, 'o-', label="Kuramoto")
plt.plot(K_values, rW, 's--', label="Winfree")
plt.xlabel("K (fuerza de acoplamiento)")
plt.ylabel("r_final")
plt.title("Transición de sincronización (bifurcación en K)")
plt.legend(); plt.grid(True); plt.show()

print(f"r_final (Kuramoto) = {r_kur[-1]:.3f}")
print(f"r_final (Winfree)  = {r_win[-1]:.3f}")
print("Simulación completada con éxito")
